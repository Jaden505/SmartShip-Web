{"ast":null,"code":"import bindEvents from '../utils/bindEvents.js';\nimport { bindProps, getPropsValues } from '../utils/bindProps.js';\nimport MapElementMixin from './mapElementMixin';\n\n/**\n *\n * @param {Object} options\n * @param {Object} options.mappedProps - Definitions of props\n * @param {Object} options.mappedProps.PROP.type - Value type\n * @param {Boolean} options.mappedProps.PROP.twoWay\n *  - Whether the prop has a corresponding PROP_changed\n *   event\n * @param {Boolean} options.mappedProps.PROP.noBind\n *  - If true, do not apply the default bindProps / bindEvents.\n * However it will still be added to the list of component props\n * @param {Object} options.props - Regular Vue-style props.\n *  Note: must be in the Object form because it will be\n *  merged with the `mappedProps`\n *\n * @param {Object} options.events - Google Maps API events\n *  that are not bound to a corresponding prop\n * @param {String} options.name - e.g. `polyline`\n * @param {=> String} options.ctr - constructor, e.g.\n *  `google.maps.Polyline`. However, since this is not\n *  generally available during library load, this becomes\n *  a function instead, e.g. () => google.maps.Polyline\n *  which will be called only after the API has been loaded\n * @param {(MappedProps, OtherVueProps) => Array} options.ctrArgs -\n *   If the constructor in `ctr` needs to be called with\n *   arguments other than a single `options` object, e.g. for\n *   GroundOverlay, we call `new GroundOverlay(url, bounds, options)`\n *   then pass in a function that returns the argument list as an array\n *\n * Otherwise, the constructor will be called with an `options` object,\n *   with property and values merged from:\n *\n *   1. the `options` property, if any\n *   2. a `map` property with the Google Maps\n *   3. all the properties passed to the component in `mappedProps`\n * @param {Object => Any} options.beforeCreate -\n *  Hook to modify the options passed to the initializer\n * @param {(options.ctr, Object) => Any} options.afterCreate -\n *  Hook called when\n *\n */\nexport default function (options) {\n  const {\n    mappedProps,\n    name,\n    ctr,\n    ctrArgs,\n    events,\n    beforeCreate,\n    afterCreate,\n    props,\n    ...rest\n  } = options;\n  const promiseName = `$${name}Promise`;\n  const instanceName = `$${name}Object`;\n  assert(!(rest.props instanceof Array), '`props` should be an object, not Array');\n  return {\n    ...(typeof GENERATE_DOC !== 'undefined' ? {\n      $vgmOptions: options\n    } : {}),\n    mixins: [MapElementMixin],\n    props: {\n      ...props,\n      ...mappedPropsToVueProps(mappedProps)\n    },\n    render() {\n      return '';\n    },\n    provide() {\n      const promise = this.$mapPromise.then(map => {\n        // Infowindow needs this to be immediately available\n        this.$map = map;\n\n        // Initialize the maps with the given options\n        const options = {\n          ...this.options,\n          map,\n          ...getPropsValues(this, mappedProps)\n        };\n        delete options.options; // delete the extra options\n\n        if (beforeCreate) {\n          const result = beforeCreate.bind(this)(options);\n          if (result instanceof Promise) {\n            return result.then(() => ({\n              options\n            }));\n          }\n        }\n        return {\n          options\n        };\n      }).then(({\n        options\n      }) => {\n        const ConstructorObject = ctr();\n        // https://stackoverflow.com/questions/1606797/use-of-apply-with-new-operator-is-this-possible\n        this[instanceName] = ctrArgs ? new (Function.prototype.bind.call(ConstructorObject, null, ...ctrArgs(options, getPropsValues(this, props || {}))))() : new ConstructorObject(options);\n        bindProps(this, this[instanceName], mappedProps);\n        bindEvents(this, this[instanceName], events);\n        if (afterCreate) {\n          afterCreate.bind(this)(this[instanceName]);\n        }\n        return this[instanceName];\n      });\n      this[promiseName] = promise;\n      return {\n        [promiseName]: promise\n      };\n    },\n    unmounted() {\n      // Note: not all Google Maps components support maps\n      if (this[instanceName] && this[instanceName].setMap) {\n        this[instanceName].setMap(null);\n      }\n    },\n    ...rest\n  };\n}\nfunction assert(v, message) {\n  if (!v) throw new Error(message);\n}\n\n/**\n * Strips out the extraneous properties we have in our\n * props definitions\n * @param {Object} props\n */\nexport function mappedPropsToVueProps(mappedProps) {\n  return Object.entries(mappedProps).map(([key, prop]) => {\n    const value = {};\n    if ('type' in prop) value.type = prop.type;\n    if ('default' in prop) value.default = prop.default;\n    if ('required' in prop) value.required = prop.required;\n    return [key, value];\n  }).reduce((acc, [key, val]) => {\n    acc[key] = val;\n    return acc;\n  }, {});\n}","map":{"version":3,"names":["bindEvents","bindProps","getPropsValues","MapElementMixin","options","mappedProps","name","ctr","ctrArgs","events","beforeCreate","afterCreate","props","rest","promiseName","instanceName","assert","Array","GENERATE_DOC","$vgmOptions","mixins","mappedPropsToVueProps","render","provide","promise","$mapPromise","then","map","$map","result","bind","Promise","ConstructorObject","Function","prototype","call","unmounted","setMap","v","message","Error","Object","entries","key","prop","value","type","default","required","reduce","acc","val"],"sources":["/Users/jadenvanrijswijk/Desktop/Programming files/IntelliJ/Assignment1-Trains/smartship-ewa-1/node_modules/@fawmi/vue-google-maps/src/components/build-component.js"],"sourcesContent":["import bindEvents from '../utils/bindEvents.js'\nimport { bindProps, getPropsValues } from '../utils/bindProps.js'\nimport MapElementMixin from './mapElementMixin'\n\n/**\n *\n * @param {Object} options\n * @param {Object} options.mappedProps - Definitions of props\n * @param {Object} options.mappedProps.PROP.type - Value type\n * @param {Boolean} options.mappedProps.PROP.twoWay\n *  - Whether the prop has a corresponding PROP_changed\n *   event\n * @param {Boolean} options.mappedProps.PROP.noBind\n *  - If true, do not apply the default bindProps / bindEvents.\n * However it will still be added to the list of component props\n * @param {Object} options.props - Regular Vue-style props.\n *  Note: must be in the Object form because it will be\n *  merged with the `mappedProps`\n *\n * @param {Object} options.events - Google Maps API events\n *  that are not bound to a corresponding prop\n * @param {String} options.name - e.g. `polyline`\n * @param {=> String} options.ctr - constructor, e.g.\n *  `google.maps.Polyline`. However, since this is not\n *  generally available during library load, this becomes\n *  a function instead, e.g. () => google.maps.Polyline\n *  which will be called only after the API has been loaded\n * @param {(MappedProps, OtherVueProps) => Array} options.ctrArgs -\n *   If the constructor in `ctr` needs to be called with\n *   arguments other than a single `options` object, e.g. for\n *   GroundOverlay, we call `new GroundOverlay(url, bounds, options)`\n *   then pass in a function that returns the argument list as an array\n *\n * Otherwise, the constructor will be called with an `options` object,\n *   with property and values merged from:\n *\n *   1. the `options` property, if any\n *   2. a `map` property with the Google Maps\n *   3. all the properties passed to the component in `mappedProps`\n * @param {Object => Any} options.beforeCreate -\n *  Hook to modify the options passed to the initializer\n * @param {(options.ctr, Object) => Any} options.afterCreate -\n *  Hook called when\n *\n */\nexport default function (options) {\n  const {\n    mappedProps,\n    name,\n    ctr,\n    ctrArgs,\n    events,\n    beforeCreate,\n    afterCreate,\n    props,\n    ...rest\n  } = options\n\n  const promiseName = `$${name}Promise`\n  const instanceName = `$${name}Object`\n\n  assert(!(rest.props instanceof Array), '`props` should be an object, not Array')\n\n  return {\n    ...(typeof GENERATE_DOC !== 'undefined' ? { $vgmOptions: options } : {}),\n    mixins: [MapElementMixin],\n    props: {\n      ...props,\n      ...mappedPropsToVueProps(mappedProps),\n    },\n    render() {\n      return ''\n    },\n    provide() {\n      const promise = this.$mapPromise\n        .then((map) => {\n          // Infowindow needs this to be immediately available\n          this.$map = map\n\n          // Initialize the maps with the given options\n          const options = {\n            ...this.options,\n            map,\n            ...getPropsValues(this, mappedProps),\n          }\n          delete options.options // delete the extra options\n\n          if (beforeCreate) {\n            const result = beforeCreate.bind(this)(options)\n\n            if (result instanceof Promise) {\n              return result.then(() => ({ options }))\n            }\n          }\n          return { options }\n        })\n        .then(({ options }) => {\n          const ConstructorObject = ctr()\n          // https://stackoverflow.com/questions/1606797/use-of-apply-with-new-operator-is-this-possible\n          this[instanceName] = ctrArgs\n            ? new (Function.prototype.bind.call(\n                ConstructorObject,\n                null,\n                ...ctrArgs(options, getPropsValues(this, props || {}))\n              ))()\n            : new ConstructorObject(options)\n\n          bindProps(this, this[instanceName], mappedProps)\n          bindEvents(this, this[instanceName], events)\n\n          if (afterCreate) {\n            afterCreate.bind(this)(this[instanceName])\n          }\n          return this[instanceName]\n        })\n      this[promiseName] = promise\n      return { [promiseName]: promise }\n    },\n    unmounted() {\n      // Note: not all Google Maps components support maps\n      if (this[instanceName] && this[instanceName].setMap) {\n        this[instanceName].setMap(null)\n      }\n    },\n    ...rest,\n  }\n}\n\nfunction assert(v, message) {\n  if (!v) throw new Error(message)\n}\n\n/**\n * Strips out the extraneous properties we have in our\n * props definitions\n * @param {Object} props\n */\nexport function mappedPropsToVueProps(mappedProps) {\n  return Object.entries(mappedProps)\n    .map(([key, prop]) => {\n      const value = {}\n\n      if ('type' in prop) value.type = prop.type\n      if ('default' in prop) value.default = prop.default\n      if ('required' in prop) value.required = prop.required\n\n      return [key, value]\n    })\n    .reduce((acc, [key, val]) => {\n      acc[key] = val\n      return acc\n    }, {})\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}