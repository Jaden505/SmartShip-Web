{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { defineComponent, ref, provide, watch, unref, nextTick, onMounted, onBeforeUnmount, renderSlot } from 'vue';\nimport { isNil } from 'lodash-unified';\nimport '../../../constants/index.mjs';\nimport '../../../hooks/index.mjs';\nimport '../../../utils/index.mjs';\nimport { getEdges, tryFocus, focusableStack, focusFirstDescendant, obtainAllFocusableElements } from './utils.mjs';\nimport { ON_TRAP_FOCUS_EVT, ON_RELEASE_FOCUS_EVT, FOCUS_TRAP_INJECTION_KEY, FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS, FOCUS_AFTER_RELEASED } from './tokens.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { useEscapeKeydown } from '../../../hooks/use-escape-keydown/index.mjs';\nimport { EVENT_CODE } from '../../../constants/aria.mjs';\nimport { isString } from '@vue/shared';\nconst _sfc_main = defineComponent({\n  name: \"ElFocusTrap\",\n  inheritAttrs: false,\n  props: {\n    loop: Boolean,\n    trapped: Boolean,\n    focusTrapEl: Object,\n    focusStartEl: {\n      type: [Object, String],\n      default: \"first\"\n    }\n  },\n  emits: [ON_TRAP_FOCUS_EVT, ON_RELEASE_FOCUS_EVT, \"focusin\", \"focusout\", \"focusout-prevented\", \"release-requested\"],\n  setup(props, {\n    emit\n  }) {\n    const forwardRef = ref();\n    let lastFocusBeforeTrapped;\n    let lastFocusAfterTrapped;\n    useEscapeKeydown(event => {\n      if (props.trapped && !focusLayer.paused) {\n        emit(\"release-requested\", event);\n      }\n    });\n    const focusLayer = {\n      paused: false,\n      pause() {\n        this.paused = true;\n      },\n      resume() {\n        this.paused = false;\n      }\n    };\n    const onKeydown = e => {\n      if (!props.loop && !props.trapped) return;\n      if (focusLayer.paused) return;\n      const {\n        key,\n        altKey,\n        ctrlKey,\n        metaKey,\n        currentTarget,\n        shiftKey\n      } = e;\n      const {\n        loop\n      } = props;\n      const isTabbing = key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;\n      const currentFocusingEl = document.activeElement;\n      if (isTabbing && currentFocusingEl) {\n        const container = currentTarget;\n        const [first, last] = getEdges(container);\n        const isTabbable = first && last;\n        if (!isTabbable) {\n          if (currentFocusingEl === container) {\n            e.preventDefault();\n            emit(\"focusout-prevented\");\n          }\n        } else {\n          if (!shiftKey && currentFocusingEl === last) {\n            e.preventDefault();\n            if (loop) tryFocus(first, true);\n            emit(\"focusout-prevented\");\n          } else if (shiftKey && [first, container].includes(currentFocusingEl)) {\n            e.preventDefault();\n            if (loop) tryFocus(last, true);\n            emit(\"focusout-prevented\");\n          }\n        }\n      }\n    };\n    provide(FOCUS_TRAP_INJECTION_KEY, {\n      focusTrapRef: forwardRef,\n      onKeydown\n    });\n    watch(() => props.focusTrapEl, focusTrapEl => {\n      if (focusTrapEl) {\n        forwardRef.value = focusTrapEl;\n      }\n    }, {\n      immediate: true\n    });\n    watch([forwardRef], ([forwardRef2], [oldForwardRef]) => {\n      if (forwardRef2) {\n        forwardRef2.addEventListener(\"keydown\", onKeydown);\n        forwardRef2.addEventListener(\"focusin\", onFocusIn);\n        forwardRef2.addEventListener(\"focusout\", onFocusOut);\n      }\n      if (oldForwardRef) {\n        oldForwardRef.removeEventListener(\"keydown\", onKeydown);\n        oldForwardRef.removeEventListener(\"focusin\", onFocusIn);\n        oldForwardRef.removeEventListener(\"focusout\", onFocusOut);\n      }\n    });\n    const trapOnFocus = e => {\n      emit(ON_TRAP_FOCUS_EVT, e);\n    };\n    const releaseOnFocus = e => emit(ON_RELEASE_FOCUS_EVT, e);\n    const onFocusIn = e => {\n      const trapContainer = unref(forwardRef);\n      if (!trapContainer) return;\n      const target = e.target;\n      const isFocusedInTrap = target && trapContainer.contains(target);\n      if (isFocusedInTrap) emit(\"focusin\", e);\n      if (focusLayer.paused) return;\n      if (props.trapped) {\n        if (isFocusedInTrap) {\n          lastFocusAfterTrapped = target;\n        } else {\n          tryFocus(lastFocusAfterTrapped, true);\n        }\n      }\n    };\n    const onFocusOut = e => {\n      const trapContainer = unref(forwardRef);\n      if (focusLayer.paused || !trapContainer) return;\n      if (props.trapped) {\n        const relatedTarget = e.relatedTarget;\n        if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {\n          setTimeout(() => {\n            if (!focusLayer.paused && props.trapped) {\n              tryFocus(lastFocusAfterTrapped, true);\n            }\n          }, 0);\n        }\n      } else {\n        const target = e.target;\n        const isFocusedInTrap = target && trapContainer.contains(target);\n        if (!isFocusedInTrap) emit(\"focusout\", e);\n      }\n    };\n    async function startTrap() {\n      await nextTick();\n      const trapContainer = unref(forwardRef);\n      if (trapContainer) {\n        focusableStack.push(focusLayer);\n        const prevFocusedElement = document.activeElement;\n        lastFocusBeforeTrapped = prevFocusedElement;\n        const isPrevFocusContained = trapContainer.contains(prevFocusedElement);\n        if (!isPrevFocusContained) {\n          const focusEvent = new Event(FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS);\n          trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);\n          trapContainer.dispatchEvent(focusEvent);\n          if (!focusEvent.defaultPrevented) {\n            nextTick(() => {\n              let focusStartEl = props.focusStartEl;\n              if (!isString(focusStartEl)) {\n                tryFocus(focusStartEl);\n                if (document.activeElement !== focusStartEl) {\n                  focusStartEl = \"first\";\n                }\n              }\n              if (focusStartEl === \"first\") {\n                focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);\n              }\n              if (document.activeElement === prevFocusedElement || focusStartEl === \"container\") {\n                tryFocus(trapContainer);\n              }\n            });\n          }\n        }\n      }\n    }\n    function stopTrap() {\n      const trapContainer = unref(forwardRef);\n      if (trapContainer) {\n        trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);\n        const releasedEvent = new Event(FOCUS_AFTER_RELEASED, FOCUS_AFTER_TRAPPED_OPTS);\n        trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);\n        trapContainer.dispatchEvent(releasedEvent);\n        if (!releasedEvent.defaultPrevented) {\n          tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body, true);\n        }\n        trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, trapOnFocus);\n        focusableStack.remove(focusLayer);\n      }\n    }\n    onMounted(() => {\n      if (props.trapped) {\n        startTrap();\n      }\n      watch(() => props.trapped, trapped => {\n        if (trapped) {\n          startTrap();\n        } else {\n          stopTrap();\n        }\n      });\n    });\n    onBeforeUnmount(() => {\n      if (props.trapped) {\n        stopTrap();\n      }\n    });\n    return {\n      onKeydown\n    };\n  }\n});\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return renderSlot(_ctx.$slots, \"default\", {\n    handleKeydown: _ctx.onKeydown\n  });\n}\nvar ElFocusTrap = /* @__PURE__ */_export_sfc(_sfc_main, [[\"render\", _sfc_render], [\"__file\", \"/home/runner/work/element-plus/element-plus/packages/components/focus-trap/src/focus-trap.vue\"]]);\nexport { ElFocusTrap as default };","map":{"version":3,"mappings":";;;;;;;;;;;;AAqCA,MAAKA,YAAaC,eAAa;EAC7BC,IAAM;EACNC,YAAc;EACdC,KAAO;IACLC,IAAM;IACNC,OAAS;IACTC,WAAa;IACbC,YAAc;MACZC,MAAM,CAACC,QAAQC,MAAM;MACrBC,OAAS;IAAA;EACX,CACF;EACAC,KAAO,GACLC,mBACAC,sBACA,WACA,YACA,sBACA,oBACF;EACAC,MAAMZ,KAAO;IAAEa;EAAQ;IACrB,MAAMC,aAAaC,GAA6B;IAC5C;IACA;IAEJC,iBAAkBC,KAAU;MAC1B,IAAIjB,KAAM,YAAW,CAACkB,WAAWC,MAAQ;QACvCN,KAAK,qBAAqBI,KAAK;MAAA;IACjC,CACD;IAED,MAAMC,UAAyB;MAC7BC,MAAQ;MACRC,KAAQ;QACN,KAAKD,MAAS;MAAA,CAChB;MACAE,MAAS;QACP,KAAKF,MAAS;MAAA;IAChB,CACF;IAEM,kBAAaG,CAAqB;MACtC,IAAI,CAACtB,MAAMC,IAAQ,KAACD,KAAM,UAAS;MACnC,IAAIkB,UAAW,SAAQ;MAEvB,MAAM;QAAEK,GAAK;QAAAC;QAAQC,OAAS;QAAAC;QAASC;QAAeC;MAAa;MACnE,MAAM;QAAE3B;MAAS;MACX,kBACJsB,QAAQM,UAAW,QAAO,CAACL,MAAU,KAACC,WAAW,CAACC;MAEpD,MAAMI,oBAAoBC,QAAS;MACnC,IAAIC,aAAaF,iBAAmB;QAClC,MAAMG,SAAY;QAClB,MAAM,CAACC,OAAOC,IAAQ,aAASF,SAAS;QACxC,MAAMG,aAAaF,KAAS;QAC5B,IAAI,CAACE,UAAY;UACf,IAAIN,sBAAsBG,SAAW;YACnCX,EAAEe,cAAe;YACjBxB,KAAK,oBAAoB;UAAA;QAC3B,CACK;UACD,KAACe,QAAY,0BAAsBO,IAAM;YAC3Cb,EAAEe,cAAe;YACb,UAAMC,SAASJ,OAAO,IAAI;YAC9BrB,KAAK,oBAAoB;UAAA,CAC3B,UACEe,YACA,CAACM,OAAOD,SAAS,CAAE,UAASH,iBAAgC,CAC5D;YACAR,EAAEe,cAAe;YACb,UAAMC,SAASH,MAAM,IAAI;YAC7BtB,KAAK,oBAAoB;UAAA;QAC3B;MACF;IACF,CACF;IAEA0B,QAAQC,wBAA0B;MAChCC,YAAc;MACdC;IAAA,CACD;IAEDC,MACE,MAAM3C,MAAMG,WACZ,EAACA,WAAgB;MACf,IAAIA,WAAa;QACfW,WAAW8B,KAAQ;MAAA;IACrB,CAEF;MAAEC,SAAW;IAAA,CACf;IAEAF,MAAM,CAAC7B,UAAU,GAAG,CAAC,CAACgC,cAAa,CAACC,aAAmB;MACrD,IAAID,WAAY;QACHA,6BAAiB,WAAWJ,SAAS;QACrCI,6BAAiB,WAAWE,SAAS;QACrCF,6BAAiB,YAAYG,UAAU;MAAA;MAEpD,IAAIF,aAAe;QACHA,kCAAoB,WAAWL,SAAS;QACxCK,kCAAoB,WAAWC,SAAS;QACxCD,kCAAoB,YAAYE,UAAU;MAAA;IAC1D,CACD;IAEK,oBAAe3B,CAAa;MAChCT,KAAKH,mBAAmBY,CAAC;IAAA,CAC3B;IACA,MAAM4B,cAAiB,GAAC5B,CAAa,SAAKX,sBAAsBW,CAAC;IAE3D,kBAAaA,CAAa;MACxB,sBAAgB6B,MAAMrC,UAAU;MACtC,IAAI,CAACsC,eAAe;MAEpB,MAAMC,SAAS/B,CAAE;MACjB,MAAMgC,eAAkB,aAAUF,aAAc,UAASC,MAAM;MAC3D,qBAAiBxC,KAAK,WAAWS,CAAC;MAEtC,IAAIJ,UAAW,SAAQ;MAEvB,IAAIlB,MAAME,OAAS;QACjB,IAAIoD,eAAiB;UACKC;QAAA,CACnB;UACLjB,SAASiB,uBAAuB,IAAI;QAAA;MACtC;IACF,CACF;IAEM,mBAAcjC,CAAa;MACzB,sBAAgB6B,MAAMrC,UAAU;MAClC,eAAWK,UAAU,CAACiC,eAAe;MAEzC,IAAIpD,MAAME,OAAS;QACjB,MAAMsD,gBAAiBlC,CACpB;QACC,KAACmC,MAAMD,aAAa,KAAK,CAACJ,aAAc,UAASI,aAAa,CAAG;UAGnEE,WAAW,MAAM;YACf,IAAI,CAACxC,WAAWC,MAAU,UAAMjB,OAAS;cACvCoC,SAASiB,uBAAuB,IAAI;YAAA;UACtC,GACC,CAAC;QAAA;MACN,CACK;QACL,MAAMF,SAAS/B,CAAE;QACjB,MAAMgC,eAAkB,aAAUF,aAAc,UAASC,MAAM;QAC/D,IAAI,CAACC,iBAAiBzC,KAAK,YAAYS,CAAC;MAAA;IAC1C,CACF;IAE2B;MAEzB,MAAMqC,QAAS;MACT,sBAAgBR,MAAMrC,UAAU;MACtC,IAAIsC,aAAe;QACjBQ,eAAeC,KAAK3C,UAAU;QAC9B,MAAM4C,qBAAqB/B,QAAS;QACXgC;QACnB,6BAAuBX,aAAc,UAASU,kBAAkB;QACtE,IAAI,CAACE,oBAAsB;UACzB,MAAMC,UAAa,OAAIC,KACrB,sBACAC,wBACF;UACcf,+BAAiBgB,qBAAqBC,WAAW;UAC/DjB,cAAckB,cAAcL,UAAU;UAClC,KAACA,WAAWM,gBAAkB;YAChCZ,SAAS,MAAM;cACb,IAAIvD,eAAeJ,KAAM;cACrB,KAACwE,QAAS,aAAY,CAAG;gBAC3BlC,SAASlC,YAAY;gBACjB,aAASqE,kBAAkBrE,YAAc;kBAC5BA;gBAAA;cACjB;cAEF,IAAIA,iBAAiB,OAAS;gBAE1BsE,gDAA2BtB,aAAa,GACxC,IACF;cAAA;cAEF,IACErB,QAAS,mBAAkB+B,kBAC3B,qBAAiB,WACjB;gBACAxB,SAASc,aAAa;cAAA;YACxB,CACD;UAAA;QACH;MACF;IACF;IAGkB;MACZ,sBAAgBD,MAAMrC,UAAU;MAEtC,IAAIsC,aAAe;QACHA,kCAAoBgB,qBAAqBC,WAAW;QAElE,MAAMM,aAAgB,OAAIT,KACxB,uBACAC,wBACF;QACcf,+BAAiBwB,sBAAsB1B,cAAc;QACnEE,cAAckB,cAAcK,aAAa;QAErC,KAACA,cAAcJ,gBAAkB;UAC1BjC,mCAA0B,IAAS,yBAAU;QAAA;QAG1Cc,kCAAoBwB,sBAAsBP,WAAW;QACnET,eAAeiB,OAAO3D,UAAU;MAAA;IAClC;IAGF4D,UAAU,MAAM;MACd,IAAI9E,MAAME,OAAS;QACP6E;MAAA;MAGZpC,MACE,MAAM3C,MAAME,OACZ,EAACA,OAAY;QACX,IAAIA,OAAS;UACD6E;QAAA,CACL;UACIC;QAAA;MACX,CAEJ;IAAA,CACD;IAEDC,gBAAgB,MAAM;MACpB,IAAIjF,MAAME,OAAS;QACR8E;MAAA;IACX,CACD;IAEM;MACLtC;IAAA,CACF;EAAA;AAEJ,CAAC;;SAxRCwC,UAAoC;IAA7BC,eAAgBC,IAAS;EAAA","names":["_sfc_main","defineComponent","name","inheritAttrs","props","loop","trapped","focusTrapEl","focusStartEl","type","Object","String","default","emits","ON_TRAP_FOCUS_EVT","ON_RELEASE_FOCUS_EVT","setup","emit","forwardRef","ref","useEscapeKeydown","event","focusLayer","paused","pause","resume","e","key","altKey","ctrlKey","metaKey","currentTarget","shiftKey","EVENT_CODE","currentFocusingEl","document","isTabbing","container","first","last","isTabbable","preventDefault","tryFocus","provide","FOCUS_TRAP_INJECTION_KEY","focusTrapRef","onKeydown","watch","value","immediate","forwardRef2","oldForwardRef","onFocusIn","onFocusOut","releaseOnFocus","unref","trapContainer","target","isFocusedInTrap","lastFocusAfterTrapped","relatedTarget","isNil","setTimeout","nextTick","focusableStack","push","prevFocusedElement","lastFocusBeforeTrapped","isPrevFocusContained","focusEvent","Event","FOCUS_AFTER_TRAPPED_OPTS","FOCUS_AFTER_TRAPPED","trapOnFocus","dispatchEvent","defaultPrevented","isString","activeElement","focusFirstDescendant","releasedEvent","FOCUS_AFTER_RELEASED","remove","onMounted","startTrap","stopTrap","onBeforeUnmount","_renderSlot","handleKeydown","_ctx"],"sources":["../../../../../../packages/components/focus-trap/src/focus-trap.vue"],"sourcesContent":["<template>\n  <slot :handle-keydown=\"onKeydown\" />\n</template>\n<script lang=\"ts\">\nimport {\n  defineComponent,\n  nextTick,\n  onBeforeUnmount,\n  onMounted,\n  provide,\n  ref,\n  unref,\n  watch,\n} from 'vue'\nimport { isNil } from 'lodash-unified'\nimport { EVENT_CODE } from '@element-plus/constants'\nimport { useEscapeKeydown } from '@element-plus/hooks'\nimport { isString } from '@element-plus/utils'\nimport {\n  focusFirstDescendant,\n  focusableStack,\n  getEdges,\n  obtainAllFocusableElements,\n  tryFocus,\n} from './utils'\nimport {\n  FOCUS_AFTER_RELEASED,\n  FOCUS_AFTER_TRAPPED,\n  FOCUS_AFTER_TRAPPED_OPTS,\n  FOCUS_TRAP_INJECTION_KEY,\n  ON_RELEASE_FOCUS_EVT,\n  ON_TRAP_FOCUS_EVT,\n} from './tokens'\n\nimport type { PropType } from 'vue'\nimport type { FocusLayer } from './utils'\n\nexport default defineComponent({\n  name: 'ElFocusTrap',\n  inheritAttrs: false,\n  props: {\n    loop: Boolean,\n    trapped: Boolean,\n    focusTrapEl: Object as PropType<HTMLElement>,\n    focusStartEl: {\n      type: [Object, String] as PropType<'container' | 'first' | HTMLElement>,\n      default: 'first',\n    },\n  },\n  emits: [\n    ON_TRAP_FOCUS_EVT,\n    ON_RELEASE_FOCUS_EVT,\n    'focusin',\n    'focusout',\n    'focusout-prevented',\n    'release-requested',\n  ],\n  setup(props, { emit }) {\n    const forwardRef = ref<HTMLElement | undefined>()\n    let lastFocusBeforeTrapped: HTMLElement | null\n    let lastFocusAfterTrapped: HTMLElement | null\n\n    useEscapeKeydown((event) => {\n      if (props.trapped && !focusLayer.paused) {\n        emit('release-requested', event)\n      }\n    })\n\n    const focusLayer: FocusLayer = {\n      paused: false,\n      pause() {\n        this.paused = true\n      },\n      resume() {\n        this.paused = false\n      },\n    }\n\n    const onKeydown = (e: KeyboardEvent) => {\n      if (!props.loop && !props.trapped) return\n      if (focusLayer.paused) return\n\n      const { key, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e\n      const { loop } = props\n      const isTabbing =\n        key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey\n\n      const currentFocusingEl = document.activeElement\n      if (isTabbing && currentFocusingEl) {\n        const container = currentTarget as HTMLElement\n        const [first, last] = getEdges(container)\n        const isTabbable = first && last\n        if (!isTabbable) {\n          if (currentFocusingEl === container) {\n            e.preventDefault()\n            emit('focusout-prevented')\n          }\n        } else {\n          if (!shiftKey && currentFocusingEl === last) {\n            e.preventDefault()\n            if (loop) tryFocus(first, true)\n            emit('focusout-prevented')\n          } else if (\n            shiftKey &&\n            [first, container].includes(currentFocusingEl as HTMLElement)\n          ) {\n            e.preventDefault()\n            if (loop) tryFocus(last, true)\n            emit('focusout-prevented')\n          }\n        }\n      }\n    }\n\n    provide(FOCUS_TRAP_INJECTION_KEY, {\n      focusTrapRef: forwardRef,\n      onKeydown,\n    })\n\n    watch(\n      () => props.focusTrapEl,\n      (focusTrapEl) => {\n        if (focusTrapEl) {\n          forwardRef.value = focusTrapEl\n        }\n      },\n      { immediate: true }\n    )\n\n    watch([forwardRef], ([forwardRef], [oldForwardRef]) => {\n      if (forwardRef) {\n        forwardRef.addEventListener('keydown', onKeydown)\n        forwardRef.addEventListener('focusin', onFocusIn)\n        forwardRef.addEventListener('focusout', onFocusOut)\n      }\n      if (oldForwardRef) {\n        oldForwardRef.removeEventListener('keydown', onKeydown)\n        oldForwardRef.removeEventListener('focusin', onFocusIn)\n        oldForwardRef.removeEventListener('focusout', onFocusOut)\n      }\n    })\n\n    const trapOnFocus = (e: Event) => {\n      emit(ON_TRAP_FOCUS_EVT, e)\n    }\n    const releaseOnFocus = (e: Event) => emit(ON_RELEASE_FOCUS_EVT, e)\n\n    const onFocusIn = (e: Event) => {\n      const trapContainer = unref(forwardRef)\n      if (!trapContainer) return\n\n      const target = e.target as HTMLElement | null\n      const isFocusedInTrap = target && trapContainer.contains(target)\n      if (isFocusedInTrap) emit('focusin', e)\n\n      if (focusLayer.paused) return\n\n      if (props.trapped) {\n        if (isFocusedInTrap) {\n          lastFocusAfterTrapped = target\n        } else {\n          tryFocus(lastFocusAfterTrapped, true)\n        }\n      }\n    }\n\n    const onFocusOut = (e: Event) => {\n      const trapContainer = unref(forwardRef)\n      if (focusLayer.paused || !trapContainer) return\n\n      if (props.trapped) {\n        const relatedTarget = (e as FocusEvent)\n          .relatedTarget as HTMLElement | null\n        if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {\n          // Give embedded focus layer time to pause this layer before reclaiming focus\n          // And only reclaim focus if it should currently be trapping\n          setTimeout(() => {\n            if (!focusLayer.paused && props.trapped) {\n              tryFocus(lastFocusAfterTrapped, true)\n            }\n          }, 0)\n        }\n      } else {\n        const target = e.target as HTMLElement | null\n        const isFocusedInTrap = target && trapContainer.contains(target)\n        if (!isFocusedInTrap) emit('focusout', e)\n      }\n    }\n\n    async function startTrap() {\n      // Wait for forwardRef to resolve\n      await nextTick()\n      const trapContainer = unref(forwardRef)\n      if (trapContainer) {\n        focusableStack.push(focusLayer)\n        const prevFocusedElement = document.activeElement\n        lastFocusBeforeTrapped = prevFocusedElement as HTMLElement | null\n        const isPrevFocusContained = trapContainer.contains(prevFocusedElement)\n        if (!isPrevFocusContained) {\n          const focusEvent = new Event(\n            FOCUS_AFTER_TRAPPED,\n            FOCUS_AFTER_TRAPPED_OPTS\n          )\n          trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus)\n          trapContainer.dispatchEvent(focusEvent)\n          if (!focusEvent.defaultPrevented) {\n            nextTick(() => {\n              let focusStartEl = props.focusStartEl\n              if (!isString(focusStartEl)) {\n                tryFocus(focusStartEl)\n                if (document.activeElement !== focusStartEl) {\n                  focusStartEl = 'first'\n                }\n              }\n              if (focusStartEl === 'first') {\n                focusFirstDescendant(\n                  obtainAllFocusableElements(trapContainer),\n                  true\n                )\n              }\n              if (\n                document.activeElement === prevFocusedElement ||\n                focusStartEl === 'container'\n              ) {\n                tryFocus(trapContainer)\n              }\n            })\n          }\n        }\n      }\n    }\n\n    function stopTrap() {\n      const trapContainer = unref(forwardRef)\n\n      if (trapContainer) {\n        trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus)\n\n        const releasedEvent = new Event(\n          FOCUS_AFTER_RELEASED,\n          FOCUS_AFTER_TRAPPED_OPTS\n        )\n        trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus)\n        trapContainer.dispatchEvent(releasedEvent)\n\n        if (!releasedEvent.defaultPrevented) {\n          tryFocus(lastFocusBeforeTrapped ?? document.body, true)\n        }\n\n        trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, trapOnFocus)\n        focusableStack.remove(focusLayer)\n      }\n    }\n\n    onMounted(() => {\n      if (props.trapped) {\n        startTrap()\n      }\n\n      watch(\n        () => props.trapped,\n        (trapped) => {\n          if (trapped) {\n            startTrap()\n          } else {\n            stopTrap()\n          }\n        }\n      )\n    })\n\n    onBeforeUnmount(() => {\n      if (props.trapped) {\n        stopTrap()\n      }\n    })\n\n    return {\n      onKeydown,\n    }\n  },\n})\n</script>\n"]},"metadata":{},"sourceType":"module"}