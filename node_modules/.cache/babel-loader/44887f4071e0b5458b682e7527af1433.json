{"ast":null,"code":"import WatchPrimitiveProperties from '../utils/WatchPrimitiveProperties';\nimport { Str } from \"./string\";\nexport function getPropsValues(vueInst, props) {\n  return Object.keys(props).reduce((acc, prop) => {\n    if (vueInst[prop] !== undefined) {\n      acc[prop] = vueInst[prop];\n    }\n    return acc;\n  }, {});\n}\n\n/**\n * Binds the properties defined in props to the google maps instance.\n * If the prop is an Object type, and we wish to track the properties\n * of the object (e.g. the lat and lng of a LatLng), then we do a deep\n * watch. For deep watch, we also prevent the _changed event from being\n * $emitted if the data source was external.\n */\nexport function bindProps(vueInst, googleMapsInst, props) {\n  for (let attribute in props) {\n    let {\n      twoWay,\n      type,\n      trackProperties,\n      noBind\n    } = props[attribute];\n    if (noBind) continue;\n    const setMethodName = 'set' + Str.capitalizeFirstLetter(attribute);\n    const getMethodName = 'get' + Str.capitalizeFirstLetter(attribute);\n    const eventName = attribute.toLowerCase() + '_changed';\n    const initialValue = vueInst[attribute];\n    if (typeof googleMapsInst[setMethodName] === 'undefined') {\n      throw new Error(`${setMethodName} is not a method of (the Maps object corresponding to) ${vueInst.$options._componentTag}`);\n    }\n\n    // We need to avoid an endless\n    // propChanged -> event $emitted -> propChanged -> event $emitted loop\n    // although this may really be the user's responsibility\n    if (type !== Object || !trackProperties) {\n      // Track the object deeply\n      vueInst.$watch(attribute, () => {\n        const attributeValue = vueInst[attribute];\n        googleMapsInst[setMethodName](attributeValue);\n      }, {\n        immediate: typeof initialValue !== 'undefined',\n        deep: type === Object\n      });\n    } else {\n      WatchPrimitiveProperties(vueInst, trackProperties.map(prop => `${attribute}.${prop}`), () => {\n        googleMapsInst[setMethodName](vueInst[attribute]);\n      }, vueInst[attribute] !== undefined);\n    }\n    if (twoWay && (vueInst.$gmapOptions.autobindAllEvents || vueInst.$attrs[eventName])) {\n      googleMapsInst.addListener(eventName, () => {\n        // eslint-disable-line no-unused-vars\n        vueInst.$emit(eventName, googleMapsInst[getMethodName]());\n      });\n    }\n  }\n}","map":{"version":3,"names":["WatchPrimitiveProperties","Str","getPropsValues","vueInst","props","Object","keys","reduce","acc","prop","undefined","bindProps","googleMapsInst","attribute","twoWay","type","trackProperties","noBind","setMethodName","capitalizeFirstLetter","getMethodName","eventName","toLowerCase","initialValue","Error","$options","_componentTag","$watch","attributeValue","immediate","deep","map","$gmapOptions","autobindAllEvents","$attrs","addListener","$emit"],"sources":["/Users/jadenvanrijswijk/Desktop/Programming files/IntelliJ/Assignment1-Trains/smartship-ewa-1/node_modules/@fawmi/vue-google-maps/src/utils/bindProps.js"],"sourcesContent":["import WatchPrimitiveProperties from '../utils/WatchPrimitiveProperties'\nimport {Str} from \"./string\";\n\nexport function getPropsValues(vueInst, props) {\n  return Object.keys(props).reduce((acc, prop) => {\n    if (vueInst[prop] !== undefined) {\n      acc[prop] = vueInst[prop]\n    }\n    return acc\n  }, {})\n}\n\n/**\n * Binds the properties defined in props to the google maps instance.\n * If the prop is an Object type, and we wish to track the properties\n * of the object (e.g. the lat and lng of a LatLng), then we do a deep\n * watch. For deep watch, we also prevent the _changed event from being\n * $emitted if the data source was external.\n */\nexport function bindProps(vueInst, googleMapsInst, props) {\n  for (let attribute in props) {\n    let { twoWay, type, trackProperties, noBind } = props[attribute]\n\n    if (noBind) continue\n\n    const setMethodName = 'set' + Str.capitalizeFirstLetter(attribute)\n    const getMethodName = 'get' + Str.capitalizeFirstLetter(attribute)\n    const eventName = attribute.toLowerCase() + '_changed'\n    const initialValue = vueInst[attribute]\n\n    if (typeof googleMapsInst[setMethodName] === 'undefined') {\n      throw new Error(\n        `${setMethodName} is not a method of (the Maps object corresponding to) ${vueInst.$options._componentTag}`\n      )\n    }\n\n    // We need to avoid an endless\n    // propChanged -> event $emitted -> propChanged -> event $emitted loop\n    // although this may really be the user's responsibility\n    if (type !== Object || !trackProperties) {\n      // Track the object deeply\n      vueInst.$watch(attribute,\n        () => {\n          const attributeValue = vueInst[attribute]\n\n          googleMapsInst[setMethodName](attributeValue)\n        },\n        {\n          immediate: typeof initialValue !== 'undefined',\n          deep: type === Object,\n        }\n      )\n    } else {\n      WatchPrimitiveProperties(\n        vueInst,\n        trackProperties.map((prop) => `${attribute}.${prop}`),\n        () => {\n          googleMapsInst[setMethodName](vueInst[attribute])\n        },\n        vueInst[attribute] !== undefined\n      )\n    }\n\n    if (twoWay && (vueInst.$gmapOptions.autobindAllEvents || vueInst.$attrs[eventName])) {\n      googleMapsInst.addListener(eventName, () => {\n        // eslint-disable-line no-unused-vars\n        vueInst.$emit(eventName, googleMapsInst[getMethodName]())\n      })\n    }\n  }\n}\n"],"mappings":"AAAA,OAAOA,wBAAwB,MAAM,mCAAmC;AACxE,SAAQC,GAAG,QAAO,UAAU;AAE5B,OAAO,SAASC,cAAc,CAACC,OAAO,EAAEC,KAAK,EAAE;EAC7C,OAAOC,MAAM,CAACC,IAAI,CAACF,KAAK,CAAC,CAACG,MAAM,CAAC,CAACC,GAAG,EAAEC,IAAI,KAAK;IAC9C,IAAIN,OAAO,CAACM,IAAI,CAAC,KAAKC,SAAS,EAAE;MAC/BF,GAAG,CAACC,IAAI,CAAC,GAAGN,OAAO,CAACM,IAAI,CAAC;IAC3B;IACA,OAAOD,GAAG;EACZ,CAAC,EAAE,CAAC,CAAC,CAAC;AACR;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASG,SAAS,CAACR,OAAO,EAAES,cAAc,EAAER,KAAK,EAAE;EACxD,KAAK,IAAIS,SAAS,IAAIT,KAAK,EAAE;IAC3B,IAAI;MAAEU,MAAM;MAAEC,IAAI;MAAEC,eAAe;MAAEC;IAAO,CAAC,GAAGb,KAAK,CAACS,SAAS,CAAC;IAEhE,IAAII,MAAM,EAAE;IAEZ,MAAMC,aAAa,GAAG,KAAK,GAAGjB,GAAG,CAACkB,qBAAqB,CAACN,SAAS,CAAC;IAClE,MAAMO,aAAa,GAAG,KAAK,GAAGnB,GAAG,CAACkB,qBAAqB,CAACN,SAAS,CAAC;IAClE,MAAMQ,SAAS,GAAGR,SAAS,CAACS,WAAW,EAAE,GAAG,UAAU;IACtD,MAAMC,YAAY,GAAGpB,OAAO,CAACU,SAAS,CAAC;IAEvC,IAAI,OAAOD,cAAc,CAACM,aAAa,CAAC,KAAK,WAAW,EAAE;MACxD,MAAM,IAAIM,KAAK,CACZ,GAAEN,aAAc,0DAAyDf,OAAO,CAACsB,QAAQ,CAACC,aAAc,EAAC,CAC3G;IACH;;IAEA;IACA;IACA;IACA,IAAIX,IAAI,KAAKV,MAAM,IAAI,CAACW,eAAe,EAAE;MACvC;MACAb,OAAO,CAACwB,MAAM,CAACd,SAAS,EACtB,MAAM;QACJ,MAAMe,cAAc,GAAGzB,OAAO,CAACU,SAAS,CAAC;QAEzCD,cAAc,CAACM,aAAa,CAAC,CAACU,cAAc,CAAC;MAC/C,CAAC,EACD;QACEC,SAAS,EAAE,OAAON,YAAY,KAAK,WAAW;QAC9CO,IAAI,EAAEf,IAAI,KAAKV;MACjB,CAAC,CACF;IACH,CAAC,MAAM;MACLL,wBAAwB,CACtBG,OAAO,EACPa,eAAe,CAACe,GAAG,CAAEtB,IAAI,IAAM,GAAEI,SAAU,IAAGJ,IAAK,EAAC,CAAC,EACrD,MAAM;QACJG,cAAc,CAACM,aAAa,CAAC,CAACf,OAAO,CAACU,SAAS,CAAC,CAAC;MACnD,CAAC,EACDV,OAAO,CAACU,SAAS,CAAC,KAAKH,SAAS,CACjC;IACH;IAEA,IAAII,MAAM,KAAKX,OAAO,CAAC6B,YAAY,CAACC,iBAAiB,IAAI9B,OAAO,CAAC+B,MAAM,CAACb,SAAS,CAAC,CAAC,EAAE;MACnFT,cAAc,CAACuB,WAAW,CAACd,SAAS,EAAE,MAAM;QAC1C;QACAlB,OAAO,CAACiC,KAAK,CAACf,SAAS,EAAET,cAAc,CAACQ,aAAa,CAAC,EAAE,CAAC;MAC3D,CAAC,CAAC;IACJ;EACF;AACF"},"metadata":{},"sourceType":"module"}